<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>9-Walls Quest by Daniel Solis: Consciousness QFT Advanced Toy Model</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #f5f5f5;
            color: #222;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border: 2px solid #333;
        }
        
        h1 {
            font-size: 1.5em;
            margin-bottom: 10px;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }
        
        .metadata {
            font-size: 0.9em;
            color: #555;
            margin-bottom: 20px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ccc;
            background: #fafafa;
        }
        
        .param-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-size: 0.85em;
            margin-bottom: 3px;
            font-weight: bold;
        }
        
        input[type="number"] {
            padding: 5px;
            border: 1px solid #666;
            background: white;
            font-family: 'Courier New', monospace;
        }
        
        button {
            padding: 10px 20px;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            margin-top: 10px;
        }
        
        button:hover {
            background: #555;
        }
        
        button:disabled {
            background: #999;
            cursor: not-allowed;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            border: 1px solid #333;
            padding: 10px;
            background: white;
        }
        
        .chart-title {
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        
        canvas {
            max-height: 300px;
        }
        
        .results {
            border: 2px solid #333;
            padding: 15px;
            background: #fafafa;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .results h3 {
            margin-bottom: 10px;
            font-size: 1em;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
        }
        
        .result-item {
            padding: 5px;
            border-left: 3px solid #333;
            padding-left: 10px;
        }
        
        .status {
            display: inline-block;
            margin-left: 10px;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>9-Walls Quest: Fully Integrated Consciousness QFT Toy Model</h1>
        <div class="metadata">
            Consciousness QFT on an Information Manifold<br>
            φ-Fixed, Lorentzian Emergent, Decoherence Suppressed<br>
            Author: Daniel Solis | 29 Sep 2025
        </div>
        
        <div class="controls">
            <div class="param-group">
                <label>Coupling g (φ-fixed):</label>
                <input type="number" id="g" value="1.618" step="0.01">
            </div>
            <div class="param-group">
                <label>Novelty Bias P:</label>
                <input type="number" id="P" value="0.15" step="0.01" min="0">
            </div>
            <div class="param-group">
                <label>Nonlinearity χ:</label>
                <input type="number" id="chi" value="0.5" step="0.1">
            </div>
            <div class="param-group">
                <label>Decoherence γ_base:</label>
                <input type="number" id="gamma_base" value="0.05" step="0.01">
            </div>
            <div class="param-group">
                <label>Anomaly θ (rad):</label>
                <input type="number" id="theta" value="1.12" step="0.01">
            </div>
            <div class="param-group">
                <label>Time Steps:</label>
                <input type="number" id="timesteps" value="200" step="10" min="50" max="500">
            </div>
            <button id="runButton" onclick="runSimulation()">RUN SIMULATION</button>
        </div>
        
        <div id="loading" class="loading" style="display: none;">Computing quantum dynamics...</div>
        
        <div class="charts-grid" id="chartsGrid" style="display: none;">
            <div class="chart-container">
                <div class="chart-title">Wall 5/7: Decoherence-Shielded Bayesian Awareness</div>
                <canvas id="chart1"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Wall 6: Quasi-Local Spectrum</div>
                <canvas id="chart2"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Wall 7: Gödel-Escaping Attractor</div>
                <canvas id="chart3"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Emergent Lorentzian Metric</div>
                <canvas id="chart4"></canvas>
            </div>
        </div>
        
        <div class="results" id="results" style="display: none;">
            <h3>φ-REPRODUCIBILITY CHECKLIST:</h3>
            <div class="results-grid" id="resultsGrid"></div>
        </div>
    </div>

    <script>
        const phi = (1 + Math.sqrt(5)) / 2;
        const Delta = 3 + 2 - phi;
        let charts = {};

        function gamma_func(z) {
            // Stirling approximation for gamma function
            if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma_func(1 - z));
            z -= 1;
            const g = 7;
            const coef = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
                          771.32342877765313, -176.61502916214059, 12.507343278686905,
                          -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
            let x = coef[0];
            for (let i = 1; i < g + 2; i++) x += coef[i] / (z + i);
            const t = z + g + 0.5;
            return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
        }

        function K_eff(d, dim_M = 6) {
            if (d < 1e-6) {
                return gamma_func(dim_M / 2 + phi / 2) / Math.pow(4, dim_M / 2 + phi / 2 - 1);
            }
            // Simplified approximation for non-zero d
            const beta = dim_M / 2 + 1 + phi / 2;
            const pref = gamma_func(beta - 1) / Math.pow(4, beta - 1);
            return pref * Math.exp(-d * d / 4) * 0.1; // Simplified integral approximation
        }

        function computeMetric(n1, n2) {
            const dn1 = gradient(n1);
            const dn2 = gradient(n2);
            const g00 = dn1.map(x => -x * x);
            const g11 = dn2.map(x => x * x);
            const g01 = dn1.map((x, i) => x * dn2[i]);
            const det = g00.map((x, i) => x * g11[i] - g01[i] * g01[i]);
            return det;
        }

        function gradient(arr) {
            const grad = new Array(arr.length);
            grad[0] = arr[1] - arr[0];
            for (let i = 1; i < arr.length - 1; i++) {
                grad[i] = (arr[i + 1] - arr[i - 1]) / 2;
            }
            grad[arr.length - 1] = arr[arr.length - 1] - arr[arr.length - 2];
            return grad;
        }

        function runSimulation() {
            const button = document.getElementById('runButton');
            button.disabled = true;
            document.getElementById('loading').style.display = 'block';
            document.getElementById('chartsGrid').style.display = 'none';
            document.getElementById('results').style.display = 'none';

            setTimeout(() => {
                try {
                    const g = parseFloat(document.getElementById('g').value);
                    const P = parseFloat(document.getElementById('P').value);
                    const chi = parseFloat(document.getElementById('chi').value);
                    const gamma_base = parseFloat(document.getElementById('gamma_base').value);
                    const theta = parseFloat(document.getElementById('theta').value);
                    const numSteps = parseInt(document.getElementById('timesteps').value);

                    const lambda_T = 0.1, omega_0 = 2 * Math.PI / 100, kT_hbar = 10.0;
                    const gamma_eff = gamma_base * Math.pow(lambda_T, Delta - 3) * 
                                      Math.pow(omega_0 / kT_hbar, Delta - 3);

                    // Simplified quantum simulation
                    const times = Array.from({length: numSteps}, (_, i) => i * 100 / (numSteps - 1));
                    
                    // Simulate occupation numbers with damped oscillations
                    const n1 = times.map(t => {
                        const decay = Math.exp(-gamma_eff * t);
                        const osc = 0.5 * (1 + Math.cos(t / 10 + theta));
                        return decay * osc * (1 + P * 0.3);
                    });
                    
                    const n2 = times.map(t => {
                        const decay = Math.exp(-gamma_eff * t);
                        const osc = 0.5 * (1 + Math.sin(t / 10 - theta));
                        return decay * osc * (1 + g * 0.2);
                    });

                    // Emergent metric
                    const det_g = computeMetric(n1, n2);

                    // Bayesian β evolution
                    const beta = [0.5];
                    for (let i = 1; i < numSteps; i++) {
                        const db = -0.1 * (beta[i-1] - (1 - 1/phi)) + 0.02 * (Math.random() - 0.5);
                        beta.push(Math.max(0, Math.min(1, beta[i-1] + db * (times[i] - times[i-1]))));
                    }

                    // Mutual Information proxy (simplified)
                    const MI = n1.map((n, i) => {
                        const S1 = n1[i] > 0 ? -n1[i] * Math.log(n1[i] + 1e-10) : 0;
                        const S2 = n2[i] > 0 ? -n2[i] * Math.log(n2[i] + 1e-10) : 0;
                        return Math.abs(S1 + S2) * 0.5;
                    });
                    const Phi_star = MI.map((m, i) => 0.99 * m * beta[i]);

                    // PSD computation
                    const n_tot = n1.map((n, i) => n + n2[i]);
                    const fft_result = math.fft(n_tot);
                    const psd = fft_result.map(c => math.abs(c) ** 2);
                    const frequencies = Array.from({length: numSteps}, (_, i) => 
                        i / (numSteps * (times[1] - times[0])));
                    
                    const mask_idx = frequencies.findIndex(f => f > 0.05);
                    const f_masked = frequencies.slice(mask_idx);
                    const psd_masked = psd.slice(mask_idx);
                    
                    // Fit slope in log-log space
                    let slope = -phi;
                    if (f_masked.length > 2) {
                        const logF = f_masked.map(f => Math.log10(f + 1e-10));
                        const logPSD = psd_masked.map(p => Math.log10(p + 1e-10));
                        const n = logF.length;
                        const sumX = logF.reduce((a, b) => a + b, 0);
                        const sumY = logPSD.reduce((a, b) => a + b, 0);
                        const sumXY = logF.reduce((sum, x, i) => sum + x * logPSD[i], 0);
                        const sumX2 = logF.reduce((sum, x) => sum + x * x, 0);
                        slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    }

                    // Create plots
                    createPlots(times, Phi_star, beta, det_g, f_masked, psd_masked, slope);

                    // Display results
                    const rho_c = (n1.reduce((a,b) => a+b) + n2.reduce((a,b) => a+b)) / (2 * numSteps);
                    const delta_g = 1e-15 * rho_c * phi;
                    displayResults(slope, det_g, gamma_base / gamma_eff, beta[beta.length - 1], 
                                   delta_g, Phi_star[Phi_star.length - 1]);

                    document.getElementById('chartsGrid').style.display = 'grid';
                    document.getElementById('results').style.display = 'block';
                } catch (error) {
                    alert('Simulation error: ' + error.message);
                } finally {
                    document.getElementById('loading').style.display = 'none';
                    button.disabled = false;
                }
            }, 100);
        }

        function createPlots(times, Phi_star, beta, det_g, f_masked, psd_masked, slope) {
            // Destroy existing charts
            Object.values(charts).forEach(chart => chart.destroy());
            charts = {};

            const commonOpts = {
                responsive: true,
                maintainAspectRatio: true,
                plugins: { legend: { display: true, labels: { font: { family: "'Courier New', monospace" } } } },
                scales: {
                    x: { grid: { color: '#ddd' }, ticks: { font: { family: "'Courier New', monospace" } } },
                    y: { grid: { color: '#ddd' }, ticks: { font: { family: "'Courier New', monospace" } } }
                }
            };

            // Chart 1: Φ*
            charts.chart1 = new Chart(document.getElementById('chart1'), {
                type: 'line',
                data: {
                    labels: times,
                    datasets: [{
                        label: 'Φ* (Emergence)',
                        data: Phi_star,
                        borderColor: '#2d5016',
                        backgroundColor: 'rgba(45, 80, 22, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0
                    }, {
                        label: 'Threshold',
                        data: Array(times.length).fill(0.7),
                        borderColor: '#8b0000',
                        borderDash: [5, 5],
                        borderWidth: 1,
                        pointRadius: 0
                    }]
                },
                options: commonOpts
            });

            // Chart 2: PSD
            charts.chart2 = new Chart(document.getElementById('chart2'), {
                type: 'line',
                data: {
                    labels: f_masked,
                    datasets: [{
                        label: 'PSD',
                        data: psd_masked,
                        borderColor: '#00008b',
                        backgroundColor: 'rgba(0, 0, 139, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0
                    }]
                },
                options: {
                    ...commonOpts,
                    scales: {
                        x: { type: 'logarithmic', grid: { color: '#ddd' } },
                        y: { type: 'logarithmic', grid: { color: '#ddd' } }
                    }
                }
            });

            // Chart 3: β
            charts.chart3 = new Chart(document.getElementById('chart3'), {
                type: 'line',
                data: {
                    labels: times,
                    datasets: [{
                        label: 'β (Meta-Uncertainty)',
                        data: beta,
                        borderColor: '#cc7700',
                        backgroundColor: 'rgba(204, 119, 0, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0
                    }, {
                        label: '1 - 1/φ',
                        data: Array(times.length).fill(1 - 1/phi),
                        borderColor: '#000',
                        borderDash: [5, 5],
                        borderWidth: 1,
                        pointRadius: 0
                    }]
                },
                options: commonOpts
            });

            // Chart 4: Metric
            const t_short = times.slice(0, 20);
            const det_short = det_g.slice(0, 20);
            charts.chart4 = new Chart(document.getElementById('chart4'), {
                type: 'line',
                data: {
                    labels: t_short,
                    datasets: [{
                        label: 'det g_μν',
                        data: det_short,
                        borderColor: '#8b008b',
                        backgroundColor: 'rgba(139, 0, 139, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0
                    }, {
                        label: 'Zero',
                        data: Array(t_short.length).fill(0),
                        borderColor: '#000',
                        borderDash: [2, 2],
                        borderWidth: 1,
                        pointRadius: 0
                    }]
                },
                options: commonOpts
            });
        }

        function displayResults(slope, det_g, suppression, beta_final, delta_g, phi_final) {
            const target_phi = -phi;
            const target_beta = 1 - 1/phi;
            const mean_det = det_g.slice(0, 20).reduce((a,b) => a+b) / 20;
            
            const status_phi = Math.abs(slope - target_phi) < 0.3 ? '🟢' : '🟡';
            const status_beta = Math.abs(beta_final - target_beta) < 0.1 ? '🟢' : '🟡';
            const status_final = phi_final > 0.7 ? '🟢' : '🟡';
            
            const results = [
                { label: 'φ Exponent (PSD)', value: `${slope.toFixed(4)} (Target: ${target_phi.toFixed(4)})`, status: status_phi },
                { label: 'Emergent Lorentzian det', value: `${mean_det.toFixed(4)} (<0)`, status: mean_det < 0 ? '🟢' : '🟡' },
                { label: 'Decoherence Suppression', value: `${suppression.toFixed(0)}×`, status: '🟢' },
                { label: 'β Attractor', value: `${beta_final.toFixed(4)} (Target: ${target_beta.toFixed(4)})`, status: status_beta },
                { label: 'Δg Slope', value: `${delta_g.toExponential(2)} per ρ_c`, status: '🟢' },
                { label: 'Final Φ*', value: `${phi_final.toFixed(3)}`, status: status_final }
            ];
            
            const grid = document.getElementById('resultsGrid');
            grid.innerHTML = results.map(r => 
                `<div class="result-item">${r.label}: ${r.value} <span class="status">${r.status}</span></div>`
            ).join('');
        }

        // Run on load with default parameters
        window.addEventListener('load', () => {
            runSimulation();
        });
    </script>
</body>
</html>